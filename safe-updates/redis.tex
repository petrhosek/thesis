
\begin{figure*}[t]
\begin{minipage}[b]{0.90\columnwidth}
\begin{lstlisting}[label=lst:original, caption={Original (correct) version of the {\footnotesize \texttt{hmgetCommand}} function in \redis.}]
robj *o = lookupKeyRead(c->db, c->argv[1]); /*@\label{line:key-found}@*/
if (o == NULL) {
  addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->argc-2));
  for (i = 2; i < c->argc; i++) {
    addReply(c,shared.nullbulk);
  }
  return;
} else {
  if (o->type != REDIS_HASH) { /*@\label{line:type-found}@*/
    addReply(c,shared.wrongtypeerr); /*@\label{line:report-error}@*/
    return; /*@\label{line:return}@*/
  }
}
addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->argc-2));
\end{lstlisting}
\end{minipage}
\hspace{2.2\columnsep}
\begin{minipage}[b]{0.9\columnwidth}
\begin{lstlisting}[label=lst:refactored, caption={Refactored (buggy) version of the {\footnotesize \texttt{hmgetCommand}} function in \redis.}]
robj *o, *value;
o = lookupKeyRead(c->db,c->argv[1]);
if (o != NULL && o->type != REDIS_HASH) {
  addReply(c,shared.wrongtypeerr); /*@\label{line:report-error2}@*/
}
addReplySds(c,sdscatprintf(sdsempty(),"*%d\r\n",c->argc-2));
for (i = 2; i < c->argc; i++) {
  if (o != NULL && (value = hashGet(o,c->argv[i])) != NULL) { /*@\label{line:hashGet}@*/
    addReplyBulk(c,value);
    decrRefCount(value);
  } else {
    addReply(c,shared.nullbulk);
  }
}
\end{lstlisting}
\end{minipage}
\end{figure*}



\redis is an advanced key-value data structure
server,\footnote{\url{http://redis.io/}} 
%% often referred to as one the most popular NoSQL databases.  Due to its
%% high-performance and low-resource requirements, \redis is being
used by many well-known services such as GitHub and Flickr.
%
Because the whole dataset is held in memory, reliability is critically
important, as a crash could result in total data loss.  However, like
any other large software system, \redis is often subject to crash
bugs.  Issue
344\footnote{\url{http://code.google.com/p/redis/issues/detail?id=344}}
is one such example.  This issue causes \redis to crash when the
\textstt{HMGET} command is used with the wrong type.  The bug was
introduced during a code refactoring applied in revision
\textstt{7fb16bac}.  The original code of the problematic
\textstt{hmgetCommand} function is shown in
Listing~\ref{lst:original}, while the (buggy) refactored version is
shown in Listing~\ref{lst:refactored}. \looseness=-1

In the original code, if the lookup on line~\ref{line:key-found} is
successful, but the type is not \textstt{REDIS\_HASH}
(line~\ref{line:type-found}), the function returns after reporting an
incorrect type
(lines~\ref{line:report-error}--\ref{line:return}). However, in the
refactored version (Listing~\ref{lst:refactored}), the
\textstt{return} statement is missing, and after reporting an
incorrect type (line~\ref{line:report-error2}), the function continues
execution and crashes inside the \textstt{hashGet} function invoked on
line~\ref{line:hashGet}.
% This results in segfault and causes database to crash.
This is a critical bug, which may result in losing some or even all
of the stored data.
%%
%% , and also trigger an \emph{append-only file}
%% corruption.  This may in turn cause another segfault when restarting
%% the server due to issue 620.  
%% %\todo{do we want to use the issue 620 as well?}
%%
%% The bug was introduced on 13 April 2010, diagnosed and reported only
%% half a year later on 12 October 2010, and fixed on 27 October 2010.
The bug was introduced in April 2010, diagnosed and reported only
half a year later in October 2010 and then fixed after fifteen days.
\looseness=-1

%% As in the case of the \lighttpd bug described in
%% \sref{sec:example}, this means that for a long time

%% which means that during this time, any \redis instance has been
%% vulnerable to a possible attack. \todo{can we find some other
%%   issues/new functionality in between?}

Below, we describe how \mx can survive this bug while running in
parallel the \redis revision \textstt{a71f072f} (\textit{the old
  version}, just before the bug was introduced) with revision
\textstt{7fb16bac} (\textit{the new version}, just after the bug).
\mx first invokes \sea to perform a static analysis of the two
binaries and construct the mappings described in
\sref{sec:sea}.  Then, \mx invokes the \mxm monitor, which
executes both versions as child processes and intercepts their system
calls.

When the new version crashes after issuing the problematic
\textstt{HMGET} command, \mxm intercepts the \textstt{SIGSEGV} signal
which is sent to the application by the operating system.  At
this point, \rem starts the recovery procedure.  First, \rem sends a
\textstt{SIGKILL} signal to the new version to terminate it.  It then
takes the last checkpoint of the new version, which was taken at the
point of the last invoked system call, which in this case is an
\textstt{epoll\_ctl} system call.  Then, \rem uses the information
provided by \sea to rewrite the stack of the new version, as detailed
in \sref{sec:rem}.  In particular, \rem replaces the return
addresses of all functions in the new version with the corresponding
addresses from the old version.  \rem also adds breakpoints at the
beginning of all the functions in the code of the new version (to
intercept indirect calls via function pointers), and then finally
restores the original processor registers of the checkpointed process
and restarts the execution of the (modified) new version.

Since the checkpoint was performed right after the execution of the system
call \textstt{epoll\_ctl}, the first thing that the code does is to
return from the \textstt{libc} wrapper that performed this system
call.  This in turn will return to the corresponding code in the old
version that invoked the wrapper, since all return addresses on the
stack have been rewritten.  From then on, the code of the old version
is executed (but in the state of the new version), until the first
system call is intercepted.  In our example, the old and the new
versions perform the same system call (and with the same arguments),
so \rem concludes that the two processes have re-converged, and thus
restores back the code of the new version by performing the steps
above in reverse, plus the additional step of synchronising their
global state (see \S\ref{sec:rem}).  Finally, the control is handed
back to the \mxm monitor, which continues to monitor the execution of
the two versions.\looseness=-1

%% The stack rewriting itself however is not enough. The newer version can still
%% use function pointers, which are part of the replica state, to invoke the
%% original code (\ie functions prefixed \texttt{one\_}). To prevent this
%% situation, \mx inserts breakpoints at the beginning of every function prefixed
%% \texttt{one\_} (\ref{sec:rem}).

